---
layout: post
title:  Java反射机制
date:   2017-2-26 13:16:00 +0800
categories: 技术博客
tag: Java基础
---

* content
{:toc}


一、反射的概念
============================

1.1 反射的定义
----------------------------
反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

1.2 反射的功能
----------------------------
+ 在运行时判断任意一个对象所属的类

+ 在运行时构造任意一个类的对象

+ 在运行时判断任意一个类所具有的成员变量和方法

+ 在运行时调用任意一个对象的方法

+ 生成动态代理

1.3 反射的优缺点
-----------------------------
为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念：

静态编译：在编译时确定类型，绑定对象即通过。

动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。

一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后发布，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。

二、反射的实例
============================

2.1 反射机制获取类
----------------------------
```java
//第一种方式：  
Class c1 = Class.forName("Employee");  

//第二种方式：  
//java中每个类型都有class属性  
Class c2 = Employee.class;  
   
//第三种方式：  
//java语言中任何一个java对象都有getClass方法  
Employeee = new Employee();  
//c3是运行时类 (e的运行时类是Employee)  
Class c3 = e.getClass(); 
```

2.2 反射机制创建类
----------------------------
```java
Class c =Class.forName("Employee");  
  
//创建此Class 对象所表示的类的一个新实例
//调用了Employee的无参数构造方法  
Object o = c.newInstance(); 
```

2.3 反射机制获取属性
----------------------------
获取所有的属性：
```java
//获取整个类  
Class c = Class.forName("java.lang.Integer");  
//获取所有的属性  
Field[] fs = c.getDeclaredFields();  
//定义可变长的字符串，用来存储属性  
StringBuffer sb = new StringBuffer();  
//通过追加的方法，将每个属性拼接到此字符串中  
//最外边的public定义  
sb.append(Modifier.toString(c.getModifiers()) + " class " + c.getSimpleName() +"{\n");  
//里边的每一个属性  
for(Field field:fs){  
    sb.append("\t");//空格  
    sb.append(Modifier.toString(field.getModifiers())+" ");
    //获得属性的修饰符，例如public，static等等  
    sb.append(field.getType().getSimpleName() + " ");
    sb.append(field.getName()+";\n");
}  
      
sb.append("}");  
System.out.println(sb); 
```

获取一个特定的属性
```java
public static void main(String[] args) throws Exception{    
    /* 
    User u = new User(); 
    u.age = 12; //set 
    System.out.println(u.age); //get 
    */  
              
    //获取类  
    Class c = Class.forName("User");  
    //获取id属性  
    Field idF = c.getDeclaredField("id");  
    //实例化这个类赋给o  
    Object o = c.newInstance();  
    //打破封装  
    idF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。  
    //给o对象的id属性赋值"110"  
    idF.set(o, "110"); 
    System.out.println(idF.get(o));  
}  
```

三、Java核心机制
==========================

3.1 两种核心机制
--------------------------
Java有两种核心机制:java虚拟机(JavaVirtual Machine)与垃圾收集机制(Garbage collection)：

+ Java虚拟机(JavaVirtual Machine)：是运行所有Java程序的抽象计算机，是Java语言的运行环境，在其上面运行Java代码编译后的字节码程序，java虚拟机实现了平台无关性。

+ Java垃圾回收(Garbage Collection)：自动释放不用对象内存空间，在java程序运行过程中自动进行，垃圾收集机制可大大缩短编程时间，保护程序的完整性，是Java语言安全性策略的一个重要部分。

3.2 Java虚拟机及其结构

java垃圾回收不需要程序员手动操作，我们经常需要关注的是java虚拟机，java虚拟机承载着程序从源码到运行的全部工作。 

Java虚拟机是可运行Java代码的假想计算机，有自己想象中的硬件，如处理器、堆栈、寄存器等，还具有相应的指令系统，可以执行 Java 的字节码程序。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 

对于 JVM 的基本结构，我们可以从下图可以大致了解：
![JVM基本结构]({{ '/styles/images/2017-3-15-reflect/20160724013055956.jpg' | prepend: site.baseurl }})

