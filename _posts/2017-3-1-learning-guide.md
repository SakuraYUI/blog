---
layout: post
title:  学习指南
date:   2017-03-01 01:00:00 +0800
categories: 文章
tag: 总结
---

* content
{:toc}


Java基础
====================

1.抽象类和接口的区别
--------------------
含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静 态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。

接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口 中的方法定义默认为 public abstract类型，接口中的成员变量类型默认为 public static final。

下面比较一下两者的语法区别： 
+ 抽象类可以有构造方法，接口中不能有构造方法。

+ 抽象类中可以有普通成员变量，接口中没有普通成员变量。

+ 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

+ 抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型,虽然 eclipse 下不报错，但应该也不行），但接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。 

+ 抽象类中可以包含静态方法，接口中不能包含静态方法。

+ 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任 意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。

+ 一个类可以实现多个接口，但只能继承一个抽象类。 

2.说说&和&&的区别。
-------------------
&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于 

```if(str != null && !str.equals(“”))```

表达式，当str为null时，后面的表达式不会执行，所以不会出现`NullPointerException`。如果将&&改为&，则会抛出`NullPointerException`异常。 例如

```if(x==33 &++y>0)```

中y的值会增长，

```if(x==33 && ++y>0)```

中y的值不会变化。 

&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f 的结果为0x01。

3.switch语句能否作用在byte、long和String类型上？ 
--------------------
在switch（expr）中，expr只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte，short，char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然long和String类型都不符合 switch的语法规定，并且不能被隐式转换成int类型，所以它们不能作用于swtich语句中。

4.使用final关键字修饰一个变量时，是引用不能变还是引用的对象不能变？ 
--------------------
使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：

```
final StringBuffer a = new StringBuffer("immutable"); 
```

执行如下语句将报告编译期错误： 

```
a=new StringBuffer(""); 
```

但是，执行如下语句则可以通过编译：

``` 
a.append("broken!");  
```

有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： 

```
public void method(final StringBuffer param) { 
} 
```
实际上这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： 

```
param.append("a");
```

5."=="和equals方法究竟有什么区别？ 
------------------
==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 

如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如```Objet obj = new Object();```变量obj是一个内存，new Object()是另一个内存，此时变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。

equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码： 

```java
String a=new String("foo"); 
String b=new String("foo"); 
```

两条 new 语句创建了两个对象，然后用a/b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以表达 式a==b将返回false，而这两个对象中的内容是相同的，所以表达式a.equals(b)将返回true。 
在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如：

```java
String input = … ;
input.equals(“quit”);
```

许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。 
如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object 类的equals方法的实现代码如下：

```java 
boolean equals(Object o) { 
return this == o; 
} 
```

这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你 编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals 方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。



JavaWeb与JavaEE
====================
1.HTTP请求中get和post的区别
--------------------
+ URL地址不同：

GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。

POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是实际的传输数据。

因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。

+ 传输数据的大小限制不同：

在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。

对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。

+ 安全性不同：

POST的安全性比GET的高。这里的安全是指真正的安全，而不同于上面GET提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过GET请求，用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。

除此之外，GET请求提交的数据还可能会造成Cross-site request frogery攻击。